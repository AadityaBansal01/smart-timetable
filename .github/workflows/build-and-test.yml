name: Build & Test

on:
  pull_request_target:
    branches: [ main ]
  workflow_dispatch:

# Keep global permissions minimal; escalate only in the comment job
permissions:
  contents: read

concurrency:
  group: pr-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  build:
    name: Build PR (sandboxed)
    runs-on: ubuntu-latest

    # Read-only in this job; never expose write perms to untrusted code
    permissions:
      contents: read
      pull-requests: read

    outputs:
      exit_code: ${{ steps.set_status.outputs.exit_code }}
      log_tail: ${{ steps.tail.outputs.tail }}

    steps:
      - name: Checkout PR HEAD from fork (no token)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.sha }}
          persist-credentials: false
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install dependencies
        run: npm ci

      - id: build
        name: Run build (capture logs)
        shell: bash
        continue-on-error: true
        run: |
          set -o pipefail
          npm run build 2>&1 | tee build.log
          # Capture npm's exit code (first command in the pipe)
          echo "code=${PIPESTATUS[0]}" >> "$GITHUB_OUTPUT"

      - id: set_status
        name: Set exit code output
        run: |
          echo "exit_code=${{ steps.build.outputs.code || 1 }}" >> "$GITHUB_OUTPUT"

      - id: tail
        name: Prepare tail of build log
        shell: bash
        run: |
          if [ -f build.log ]; then
            tail -n 50 build.log > tail.log
          else
            echo "No log captured." > tail.log
          fi
          {
            echo "tail<<'EOF'"
            cat tail.log
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Upload full build log
        if: ${{ always() && hashFiles('build.log') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: build-log
          path: build.log
          retention-days: 14
          if-no-files-found: ignore
          overwrite: true

  comment:
    name: Comment build result on PR
    runs-on: ubuntu-latest
    needs: build

    # Write perms only here; this job does NOT run untrusted code
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Download build log (optional)
        if: always()
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: build-log
          path: .

      - name: Post / update PR comment
        uses: actions/github-script@v7
        env:
          EXIT_CODE: ${{ needs.build.outputs.exit_code }}
          LOG_TAIL: ${{ needs.build.outputs.log_tail }}
        with:
          script: |
            const fs = require('fs');
            const marker = '<!-- ci:build-status -->';
            const { owner, repo } = context.repo;
            const issue_number = context.payload.pull_request.number;

            // Prefer full log (artifact), else fall back to tail from outputs
            let tail = process.env.LOG_TAIL || 'No log captured.';
            try {
              const content = fs.readFileSync('build.log', 'utf8');
              const lines = content.trim().split('\n');
              tail = lines.slice(-50).join('\n') || tail;
            } catch (_) {}

            const exitCode = Number(process.env.EXIT_CODE || 1);
            const title = exitCode === 0
              ? '✅ **Success — build passed**'
              : '❌ **Failed — build error (last 50 lines)**';

            const body = [
              marker,
              title,
              '',
              exitCode === 0
                ? '> No errors reported.'
                : '```text\n' + tail + '\n```',
              '',
              `Workflow run: ${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`
            ].join('\n');

            // Find existing comment with our marker
            const { data: comments } = await github.rest.issues.listComments({
              owner, repo, issue_number, per_page: 100
            });
            const existing = comments.find(c => (c.body || '').includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner, repo, comment_id: existing.id, body
              });
            } else {
              await github.rest.issues.createComment({
                owner, repo, issue_number, body
              });
            }
